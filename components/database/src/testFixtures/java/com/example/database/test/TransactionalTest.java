/*
 * Copyright 2020 Adib Saikali
 *
 */

package com.example.database.test;

import static com.example.util.Args.notBlank;
import static com.example.util.Args.notNull;
import static com.example.util.Args.requireTrue;

import com.example.database.Identifiable;
import com.example.database.jpa.PersistableObject;
import com.example.test.spring.ApplicationContextTest;
import java.util.Date;
import java.util.Map;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.Table;
import org.assertj.core.api.Assertions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.test.jdbc.JdbcTestUtils;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.TransactionSynchronizationManager;
import org.springframework.transaction.support.TransactionTemplate;

@Transactional
public abstract class TransactionalTest extends ApplicationContextTest {

  @Autowired protected JdbcTemplate jdbcTemplate;
  @Autowired protected TransactionTemplate transactionTemplate;
  @Autowired protected TxUtils txUtils;
  @Autowired protected EntityManager entityManager;

  public Map<String, Object> queryForMap(String sql) {
    return jdbcTemplate.queryForMap(sql);
  }

  public void assertRowCount(String tableName, int expected) {
    Assertions.assertThat(count(tableName)).isEqualTo(expected);
  }

  /**
   * Counts the number of rows from the specified table that meet the specified where cause. This is
   * very useful for checking that service methods did change the database in some way.
   *
   * @param tableName the name of the table
   * @param whereClause the where clause
   * @return the number of rows
   */
  public int countWhere(String tableName, String whereClause) {
    return JdbcTestUtils.countRowsInTableWhere(this.jdbcTemplate, tableName, whereClause);
  }

  /**
   * Counts the rows of a table using jdbc.
   *
   * @param tableName the name of the table without a schema
   * @return the number of rows in the tables
   */
  public int count(String tableName) {
    return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName);
  }

  /**
   * Insert a row into the specified table and return a the columns that are generated by the
   * database as a {@code KeyHolder}.
   *
   * @param tableName name of the table to insert into
   * @param row the column values to insert into the tables
   * @param generatedKeyNames the columns values that will be generate by the database
   * @return {@link KeyHolder} contains the values of the generated columns
   */
  public KeyHolder insert(String tableName, Row row, String... generatedKeyNames) {
    SimpleJdbcInsert insert = new SimpleJdbcInsert(jdbcTemplate);
    insert.withTableName(tableName).setGeneratedKeyNames(generatedKeyNames);
    return insert.executeAndReturnKeyHolder(row.map);
  }

  /**
   * Insert the row columns into the specified table.
   *
   * @param tableName the database table to insert the row into
   * @param row the collection of columns to insert
   */
  public int insert(String tableName, Row row) {
    SimpleJdbcInsert insert = new SimpleJdbcInsert(jdbcTemplate);
    MapSqlParameterSource mapSqlParameterSource = new MapSqlParameterSource(row.map);
    return insert.withTableName(tableName).execute(mapSqlParameterSource);
  }

  /**
   * This method is is used to insert a columns into the table mapped by the
   * TimeStampedPersistableObject. The name of the table, the schema, of the table are extracted
   * from the {@code @Enity} mapping of the TimeStampedPersistableObject. This method will also set
   * the version column to 0, and the insert_ts, update_ts to the current time.
   *
   * <p>{@code Row row = new Row("username", "jim@example.com").column("name", "Jim Smith");} <br>
   * {@code Integer pkey = insert(UserAccount.class, row);}
   *
   * @param persistableObjectClass the class that extends {@link PersistableObject}
   * @param row the column values to insert
   * @return the primary key of the object
   * @see PersistableObject
   */
  public Integer insert(Class<? extends PersistableObject> persistableObjectClass, Row row) {
    String tableName = entityTableName(persistableObjectClass);

    // set the standard fields
    Date now = new Date();
    row.column("version", 0).column("insert_ts", now).column("update_ts", now);

    // execute the insert statement and return the pkey
    SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
    simpleJdbcInsert.withTableName(tableName).setGeneratedKeyName("pkey");
    Integer pkey = simpleJdbcInsert.executeAndReturnKey(row.map).intValue();

    return notNull(pkey);
  }

  /** Delete rows from the table that meet the where clause. */
  public int deleteRowsWhere(String tableName, String whereClause) {
    notBlank(tableName);
    notBlank(whereClause);

    String sql = "DELETE FROM " + tableName + " WHERE " + whereClause;

    return jdbcTemplate.queryForObject(sql, Integer.class);
  }

  /**
   * Delete all rows from the specified tables.
   *
   * @param tableNames the names of the tables to delete from
   * @return the total number of rows deleted from all specified tables
   */
  public int deleteRows(String... tableNames) {
    return JdbcTestUtils.deleteFromTables(jdbcTemplate, tableNames);
  }

  /**
   * Determine the fully qualified name of a table that a JPA entity is mapped to. which is
   * schemaName.tableName
   *
   * @param entity the entity class that should have {@code @Table} and {@code @Entity} annotations.
   * @return The table that the entity is mapped to
   */
  public String entityTableName(Class<?> entity) {
    // check that the class is an @entity and with @Table
    requireTrue(
        entity.isAnnotationPresent(Entity.class),
        entity.getName() + " does not have @Entity annotation");
    requireTrue(
        entity.isAnnotationPresent(Table.class),
        entity.getName() + " does not have @Entity annotation");

    // extract table name
    Table table = entity.getAnnotation(Table.class);
    if (table.schema() == null || table.schema().isEmpty()) {
      return table.name();
    } else {
      return table.schema() + "." + table.name();
    }
  }

  /**
   * Count the number of rows in the table that the specified entity is mapped to using raw jdbc.
   *
   * @param entityClass the entity class that we will extract a table name from
   * @param whereClause the where clause for the search
   * @return the number of rows
   */
  public int countRows(Class<?> entityClass, String whereClause) {
    if (TransactionSynchronizationManager.isActualTransactionActive()) {
      this.entityManager.flush();
    }
    return JdbcTestUtils.countRowsInTableWhere(
        this.jdbcTemplate, entityTableName(entityClass), whereClause);
  }

  /** Count all the rows of the table that the entity is mapped to. */
  public int countRows(Class<?> entityClass) {
    if (TransactionSynchronizationManager.isActualTransactionActive()) {
      this.entityManager.flush();
    }
    return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, entityTableName(entityClass));
  }

  /**
   * Delete the persistable object from the database using the jdbc template, avoliding the need to
   * use JPA do the delete.
   *
   * @param object instance of com.evctools.jpa.PersistableObject to be delete, must have a non null
   *     pkey
   * @return the number of rows deleted should be 0 or 1
   */
  public int delete(Identifiable object) {
    notNull(object.getId());
    String tableName = this.entityTableName(object.getClass());
    String sql = "DELETE FROM " + tableName + " WHERE id=" + object.getId();
    return jdbcTemplate.update(sql);
  }

  /** Delete all rows from the tables the passed in entities are mapped to. */
  public int deleteAllRows(Class<?>... entityClasses) {
    String[] tableNames = new String[entityClasses.length];
    for (int i = 0; i < entityClasses.length; i++) {
      tableNames[i] = entityTableName(entityClasses[i]);
    }

    return JdbcTestUtils.deleteFromTables(jdbcTemplate, tableNames);
  }

  /**
   * Counts the number of instance of the persistance object, by searching for the object using its
   * pkey.
   *
   * @param object the persistable we want to count
   * @return 0 or 1
   */
  public int instanceCount(Identifiable object) {
    String tableName = entityTableName(object.getClass());
    String sql = "SELECT COUNT(0) FROM  " + tableName + " WHERE id = " + notNull(object.getId());
    return jdbcTemplate.queryForObject(sql, Integer.class);
  }

  /**
   * Checks if a persistable object is in the database or not.
   *
   * @param clazz the class of the persistable object
   * @param pkey the primary key of the persistable object
   * @return true if the persistable object is in the database, false otherwise
   */
  public boolean inDatabase(Class<? extends Identifiable> clazz, Integer pkey) {
    String tableName = entityTableName(clazz);
    String sql = "SELECT COUNT(0) FROM  " + tableName + " WHERE id = " + notNull(pkey);
    int count = jdbcTemplate.queryForObject(sql, Integer.class);
    if (count == 1) {
      return true;
    } else if (count == 0) {
      return false;
    } else {
      throw new IllegalStateException(
          "There is more than one persistable object instance with the same pkey");
    }
  }
}
